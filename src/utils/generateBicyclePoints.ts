import * as THREE from "three";
import { addWheels } from "./bikeParts/addWheels";
import { addFrame } from "./bikeParts/addFrame";
import { addSeatpostAndSaddle } from "./bikeParts/addSeatpostAndSaddle";
import { addHandlebars } from "./bikeParts/addHandlebars";
import { addDrivetrain } from "./bikeParts/addDrivetrain";
import { addRoadSurface } from "./bikeParts/addRoadSurface";

/**
 * Bicycle Point Cloud Generator
 * 
 * Generates a detailed 3D bicycle model made of particles with:
 * - Detailed wheels with spokes and hubs
 * - Frame with realistic geometry and lugs
 * - Drop bars with hoods and tape
 * - Anatomical saddle with rails
 * - Complete drivetrain with chainrings, cassette, and derailleur
 * - Road surface with finish line
 * 
 * Each component is generated by specialized modules in ./bikeParts/
 */

// Colors
const ORANGE_COLOR = new THREE.Color("#f87f01");
const WHITE_COLOR = new THREE.Color("#ffffff");
const GRAY_COLOR = new THREE.Color("#505050");
const BLACK_COLOR = new THREE.Color("#202020");

/**
 * Generates 3D points and colors for a detailed bicycle and road surface.
 * @param count Total number of particles (including padding).
 * @returns Object containing position and color arrays.
 */
export function generateBicyclePoints(count: number): { positions: THREE.Vector3[]; colors: THREE.Color[] } {
  // Initialize points array with estimated capacity to reduce reallocations
  const points: THREE.Vector3[] = [];
  const colors: THREE.Color[] = [];

  // Geometry parameters
  const scale = 1.4;
  const wheelRadius = 0.9 * scale;
  const wheelBase = 2.0 * scale;
  const frameHeight = 1.2 * scale;
  const bottomBracketHeight = 0.5 * scale;
  const seatTubeHeight = 1.2 * scale;
  const roadY = -wheelRadius * 1.2;

  // Key reference points
  const rearWheelCenter = new THREE.Vector3(-wheelBase / 2 - 0.3 * scale, 0, 0);
  const frontWheelCenter = new THREE.Vector3(wheelBase / 2, 0, 0);
  const bottomBracket = new THREE.Vector3(-wheelBase / 4, bottomBracketHeight, 0);
  const seatTop = new THREE.Vector3(-wheelBase / 4, bottomBracketHeight + seatTubeHeight, 0);
  const headTubeBottom = new THREE.Vector3(wheelBase / 4, bottomBracketHeight + wheelRadius / 1.5, 0);
  const headTubeTop = new THREE.Vector3(wheelBase / 4, bottomBracketHeight + frameHeight, 0);
  const frameWidth = wheelRadius * 0.09;

  // Track starting points count for each component to monitor distribution
  const pointCountBefore = {
    start: 0,
    wheels: 0,
    frame: 0,
    seatpost: 0,
    handlebars: 0,
    drivetrain: 0,
    road: 0,
    finish: 0
  };

  // Execute all parts via imported modules with point tracking
  pointCountBefore.start = points.length;
  addWheels(points, colors, rearWheelCenter, frontWheelCenter, wheelRadius, WHITE_COLOR);
  pointCountBefore.wheels = points.length;
  
  addFrame(points, colors, bottomBracket, headTubeBottom, headTubeTop, seatTop, rearWheelCenter, frontWheelCenter, frameWidth, ORANGE_COLOR);
  pointCountBefore.frame = points.length;
  
  addSeatpostAndSaddle(points, colors, seatTop, seatTubeHeight, wheelRadius, frameWidth, ORANGE_COLOR);
  pointCountBefore.seatpost = points.length;
  
  addHandlebars(points, colors, headTubeTop, wheelRadius, frameWidth, ORANGE_COLOR);
  pointCountBefore.handlebars = points.length;
  
  addDrivetrain(points, colors, bottomBracket, rearWheelCenter, wheelRadius, frameWidth, ORANGE_COLOR, WHITE_COLOR);
  pointCountBefore.drivetrain = points.length;
  
  addRoadSurface(points, colors, wheelBase, scale, roadY, WHITE_COLOR, GRAY_COLOR, ORANGE_COLOR);
  pointCountBefore.road = points.length;
  
  // Center the model
  const box = new THREE.Box3().setFromPoints(points);
  const ctr = box.getCenter(new THREE.Vector3());
  ctr.y = 0;
  points.forEach(p => p.sub(ctr));

  // Log component point distribution to help with tuning
  console.log("Point distribution:", {
    wheels: pointCountBefore.wheels - pointCountBefore.start,
    frame: pointCountBefore.frame - pointCountBefore.wheels,
    seatpost: pointCountBefore.seatpost - pointCountBefore.frame,
    handlebars: pointCountBefore.handlebars - pointCountBefore.seatpost,
    drivetrain: pointCountBefore.drivetrain - pointCountBefore.handlebars,
    road: pointCountBefore.road - pointCountBefore.drivetrain,
    total: points.length
  });

  // Pad to count
  if (points.length < count) {
    console.log(`Padding with ${count - points.length} points`);
    while (points.length < count) {
      points.push(new THREE.Vector3(0, -999, 0));
      colors.push(BLACK_COLOR);
    }
  } else if (points.length > count) {
    console.log(`Warning: Generated ${points.length} points, but only ${count} requested. Truncating.`);
  }

  return {
    positions: points.slice(0, count),
    colors: colors.slice(0, count),
  };
} 